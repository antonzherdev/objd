package core.chain

class Option<V> extends Seq<V> {
    private static val _none : any? = None<any>()
    static def none<V> : V? = _none
    static def apply<V>(value : V) : V? = if(value == nil) _none else Some<V>(value)
    static def some<V>(value: V) : V? = if(value == nil) throw "Some with null" else Some<V>(value)

    def get : V
    def getOrElse(f: () -> V) : V
    def getOr(value: V) : V
    def getOrNil : V
    def map<B>(f : V -> B) : B?
    def flatMap<B>(f:V -> B?) : B?
    def filter(f : V -> bool) : V?
    def isEmpty : bool
    def isDefined : bool
    def for(each : V -> void)
    def try(each : V -> void) : bool
    def iterator : Iterator<V>
}

class None<V> extends Option<V> {
    def count : uint = 0
    def get : V = throw "Get from empty"
    def getOrElse(f: () -> V) : V = f()
    def getOr(value: V) : V = value
    def getOrNil : V = nil
    def for(each : V -> void) {}
    def map<B>(f : V -> B) : B? = self
    def flatMap<B>(f : V -> B?) : B? = self
    def filter(f : V -> bool) : V? = self
    def isEmpty : bool = true
    def isDefined : bool = false
    def iterator : Iterator<V> = EmptyIterator.instance
    def go(on : V -> bool) : bool = true
    def try(each : V -> void) : bool = false
    def contains(item : V) : bool = false
}


class Some<V> (value : V) extends Option<V> {
    def count : uint = 1
    def get : V = value
    def getOrElse(f: () -> V) : V = value
    def getOrNil : V = value
    def getOr(value: V) : V = self.value
    def map<B>(f : V -> B) : B? = Some<B>(f(value))
    def flatMap<B>(f : V -> B?) : B? = f(value)
    def filter(f : V -> bool) : V? = if(f(value)) self else Option.none<V>
    def isEmpty : bool = false
    def isDefined : bool = true
    def iterator : Iterator<V> = SomeIterator<V>(value)
    def for(each : V -> void) {
        each(value)
    }
    def try(each : V -> void) : bool = {
        each(value)
        true
    }
    def go(on : V -> bool) : bool = on(value)
    def contains(item : V) : bool = value == item
}

class SomeIterator<V>(value : V) extends Iterator<V> {
    var hasNext = true

    def next : V = {
        hasNext = false
        value
    }
}