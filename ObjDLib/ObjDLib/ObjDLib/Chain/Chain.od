package core.chain

stub class Chain<A> extends ImIterable<A> {
    static pure def chainWith<T>(collection:Traversable<T>) : Chain<T>

    pure def filter(: A -> bool) : Chain<A>
    pure def map<B>(: A -> B) : Chain<B>
    pure def mapOpt<B>(: A -> B?) : Chain<B>
    pure def flatMap<B>(: A -> Traversable<B>) : Chain<B>
    pure def flat<B>(self : Chain<Traversable<B>>) : Chain<B>
    pure def filterCast<B>( : ClassType<B>) : Chain<B>

    pure def combinations : Chain<(A, A)>
    pure def uncombinations<B>(self : Chain<(B, B)>) : Chain<B>
    pure def neighbors : Chain<(A, A)>
    pure def neighborsRing : Chain<(A, A)>
    pure def mul<B>(: Traversable<B>) : Chain<(A,B)>

    pure def group<K>(by : A -> K) : Chain<(K, [A])>
    pure def group<K, B>(by : A -> K, map : A -> B) : Chain<(K, [B])>
    pure def group<K, C extends Traversable<K>>(by : A -> K, withBuilder : () -> Builder<A, C>) : Chain<(K, C<A>)>
    pure def group<B, K, C extends Traversable<K>>(by : A -> K, map : A -> B, withBuilder : () -> Builder<B, C>) : Chain<(K, C<B>)>
    pure def group<K, V>(by : A -> K, fold : (V, A) -> V, withStart : () -> V) : Chain<(K, V)>

    pure def zip<B>(a: Iterable<B>) : Chain<(A, B)>
    pure def zip<B, X>(a : Iterable<B>, by : (A, B) -> X) : Chain<X>
    pure def zipFor<B>(a : Iterable<B>, by : (A, B) -> void) : void
    pure def zip3<B, C>(a: Iterable<B>, b : Iterable<C>) : Chain<(A, B, C)>
    pure def zip3<B, C, X>(a : Iterable<B>, b : Iterable<C>, by : (A, B, C) -> X) : Chain<X>

    pure def join<K, V1, V2>(self : Chain<(K, V1)>, chain : Iterable<(K, V2)>) : Chain<K, (V1, V2)>

    pure def prepend(: Iterable<A>) : Chain<A>
    pure def append(: Iterable<A>) : Chain<A>
    pure def exclude(: Iterable<A>) : Chain<A>
    pure def intersect(: Iterable<A>) : Chain<A>

    pure def reverse : Chain<A>
    pure def reverse(when : bool) : Chain<A>
    pure def distinct : Chain<A>
    pure def sort<B extends Comparable<B>> (self : Chain<B>) : Chain<A>
    pure def sortDesc<B extends Comparable<B>> (self : Chain<B>) : Chain<A>
    pure def sort(:(A, A) -> int) : Chain<A>
    pure def sortBy : SortBuilder<A>
    pure def shuffle : Chain<A>

    pure def fold<B>(start : B, by : (B, A) -> B) : B
    override def count : uint
    override def for(each: A -> void)
    override def head : A?
    def last : A?
    pure def top(numbers: int) : Chain<A>
    pure def randomItem : A?
    pure def randomItem(seed : Seed) : A?
    override def find(where: A -> bool) : A?
    override def exists(where: A -> bool) : bool
    override def all(confirm: A -> bool) : bool
    override def isEmpty : bool
    pure def gap<B extends Comparable<B>> (self : Chain<B>) : (A, A)?
    pure def min<B extends Comparable<B>> (self : Chain<B>) : A?
    pure def max<B extends Comparable<B>> (self : Chain<B>) : A?
    pure def toStringWith(start : string, delimiter : string, end : string) : string
    pure def toStringWith(delimiter : string) : string
    pure def or(self : Chain<bool>) : bool
    pure def and(self : Chain<bool>) : bool

    pure def toArray : [A]
    pure def toList : ImList<A>
    pure def toSet : Set<A>
    pure def toTreeSet<B extends Comparable<B>>(self : Chain<B>) : ImTreeSet<A>
    pure def toMap<K, V>(self : Chain<(K, V)>) : [K : V]
    pure def charsToString(self : Chain<char>) : string

    pure def future<V, R>(self : Chain<Future<V>>, f : Chain<V> -> R) : Future<R>
    pure def future<V>(self : Chain<Future<V>>) : Future<[V]>
    pure def voidFuture(self : Chain<Future<void>>) : Future<void>
}


stub trait ChainLink<A, B>{
    def build(yield : Yield<B>) : Yield<A>
}